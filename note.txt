alias viens33=‘vi /etc/sysconfig/network-scripts/ifcfg-ens33’
unalias viens33
mysql grant all on *.* to 'test_1'@'localhost' identified by '123456'; 修改test_1密码，测试有效
mysql SET PASSWORD FOR 'test_1'@'localhost' = PASSWORD('123456789');	修改密码命令2,测试有效
mysql alter user 'test_1'@'localhost' identified by '123456';	修改密码命令3,测试有效
mysql desc test; 查询表的字段信息，了解后可以读取想要的信息
mysql select * from user;	读取所有表的内容，*可改成某些字段，逗号分隔

mysql create table test(id int,name varchar(20));		创建一个表
mysql insert into test value(3,'tany');		往表内插入信息
mysql update test set name='jing' where id=3;	修改信息
mysql delete from test where id = 3;		删除一行
mysql drop table test;			删除表
mysql show grants for 'zab'@'127.0.0.1';	查看一个用户的权限
mysql show grants;			查看当前用户权限；
mysql select Host,User from user;			查看mysql数据库的user表，显示了用户名和用户应连接的Host
mysql drop user 'yangxin'@'localhost';		删除用户
mysql rename user 'test3'@'%' to 'test1'@'%';		修改帐户和host
cat -A /etc/passwd #显示全部字符；
cat -n /etc/passwd #显示行数；
lsattr
chattr +i  #不能修改；
chattr -i
chattr +a #可touch，可追加；
chmod u+s  #给二进制文件添加管理员权限；
chmod g+s #给二进制文件添加管理员属组权限；目录加上s权限之后，之后所有生成的目录和文件的属主跟原目录一样，可让这个目录属于某一个组；
chmod o+t #给/tmp这样的公共目录，谁的东西谁作主，别人不能删除；
find /etc -type d -name "sshd*"
find /etc -type f -mtime -1 #1天以内；
find / -inum 33583395 #查找硬链接；
find /root -type f -mmin -60 #60分钟以内；
find /root -size -10k -exec ls -lh {} \;
find /opt /usr /var -name foo.scala -type f     # search multiple dirs
find . -type f \( -name "*.c" -o -name "*.sh" \)                       # *.c and *.sh files  
find . -type f \( -name "*cache" -o -name "*xml" -o -name "*html" \)   # three patterns
find . -type f -not -name "*.html"                                # find all files not ending in ".html"  
find . -type f -name "*.java" -exec grep -l StringBuffer {} \;    # list the file name which have "StringBuffer";
find . -type f -name "*.gz" -exec zgrep 'GET /foo' {} \;          # search for a string in gzip files;
groupadd -g 1010 gt #指定组号添加组；
groupdel gt
useradd ut #新建用户，自动生成一样的组名，一般情况下gid跟uid一致；
useradd -u 1004 -g grp2 user3 #指定uid 和组(组名或组号） 新建用户；
useradd -u 1004 -g grp2 -d /home/tan -s /sbin/nologin user4 #-d指定家目录，-s指定用户的shell（不能登陆）；
useradd -M user5 #不建家目录；
userdel user8 #删除配置文件，不删除家目录;
userdel -r user7 #删除用户同时删除家目录；
usermod -u 1010 username #修改uid
usermod -g 1010 username #修改gid(主组）
usermod -d /home/kdjjf username #修改用户家目录，目录里内容要添加，不然用户使用有问题；
usermod -s /sbin/nologin username #修改用户的shell(不能登陆）
id user1 #查看用户的ID和组信息；
usermod -G grp2, user5 username #指定扩展组，指定一个扩展组后，再指定一个扩展组，原来的会被替换，要同时指定需要的多个扩展组；
passed -l user1 #锁定密码
passwd -u user1 #解锁
usermod -L user1 #锁定，加了一个!在密码字段的最前面
usermod -U user1 #解锁
passwd --stdin user5 #修改密码，明文显示，只输入一次；
echo "111222" |passwd --stdin user5 #一条命令修改好命令；
echo -e "12312312\n12312312" |passwd user3 #一条命令修改密码，输入了两次密码；
yum install -y expect #安装expect
mkpasswd -l 12 -s 0 #使用mkpasswd命令，-l 指定密码长度，-s 指定多少位特殊符号
visudo
visudo "root ALL=(ALL) NOPASSWD: /usr/bin/ls, usr/bin/cat" #配置文件样例；
mkfs
mke2fs -b 8192 /dev/sdb1 #8k的块，适合存储视频，图片；
mke2fs -b 2048 /dev/sdb1 #2K的小块，适合存储大量小文件；
-m 预留空间，reserved for the super user
mke2fs -m 0.1 /dev/sdb1 #可以只预留0.1;
mke2fs -i 8192 -t ext4 /dev/sdb1 #1个inode对应少一点空间，有更多inode,一般inode对应16K;
blkid #查看所有块设备；
mount -o rw /dev/sdb #读写；
mount -o ro /dev/sdb #只读；
mount -o remount /dev/sdb #重新挂载；
mount -o remount, ro /dev/sdb
swap dd if=/dev/zero of=/tmp/newdisk bs=1M count=100 #dd用于复制文件，从/dev/zero复制零到/tmp/newdisk(块大小为1M，数量100)
mkswap -f /tmp/newdisk #格式化；
swapon /tmp/newdisk #把swap挂载；
swapoff /tmp/newdisk #卸载
gzip
gzip -d #解压；
gzip -c #新建压缩文件；
bzip2
bzip2 -d
bzip2 -c #新建压缩文件；
xz 
xz -d
xz -c #新建压缩文件;
zip 1.txt.zip 1.txt
zip -r 123.zip 123/
unzip 1.txt.zip
unzip dir1.zip -d ~/  #解压缩到指定路径；
tar -cvf dir3.tar --exclude dir3/1.txt --exclude dir3/2.txt dir3 1.txt		#多个不打包的文件，要逐一列出来；
tar -tf aming.tar #list content;
rpm -ql
yum grouplist
yum groupinstall
yum info 
yum clean all
yum repolist all
yum install zsh --downloadonly
yum install zsh --downloadonly --downloaddir=/tmp/
ldd /bin/ls
yumdownloader
yum install -y bash-completion
cut -c 1 #截取第1个字符
sort -n #按数字大小排；
sort
sort -r #反向
wc -l统计行数
wc -m统计字符数，包括换行符和tab;
wc -w 统计单词数，单词以空格和换行分格
uniq, 去除连续重复的行；（跟sort一起使用）；-c统计重复个数；
split -b 1K a.txt	#以1K的大小切割文件，连原文件共762个文件，自动命名；
split -b 1K a.txt as.		#指定前缀命名；
split -l 1000 a.txt	#以每1000行分隔文件；
[ -d dira ] && mkdir dirb	#第一条命令成功，执行第二条命令；第一条命令不成功，第二条命令不执行；相当于两条命令同命相连；
[ -d dirc ] || mkdir dirc		#||表示或者，第一条命令结果为1，第二条命令就不执行；第一条命令结果为0，执行第二条命令，二选一；
grep -c 行数
grep -i 不区分大小写
grep -n 显示行号
grep -v 取反
grep -r 遍历所有子目录
grep -A -B -C 下面 上面 上下一起
grep r.o 代表查找的关键词是三个字符，其中.代表所有字符包括空格和符号;
grep o* 代表查找的关键词是o，0个或以上的o都符合条件;
grep oo* 代表查找的关键词是o+o*,一个或以上的o符合条件；
grep ro* 代表查找的关键词是r+o*，r加上0个或以上的o都符合条件；
grep .* 代表任意个任意字符，前后加内容使用更方便；
grep o{2} 代表带两个相连的o都符合条件；
grep ro+ 代表r加上一个或以上的o符合条件；+要用egrep使用；
grep ro 代表有一个ro符合条件，跟上面的高亮不一样；
grep ro? 代表r加上0个或1个o符合条件,r, ro符合条件；?要用egrep使用；
grep root|bash 代表带其中一个关键词的行符合条件；|要用egrep使用；
grep (oo){2} 代表连续两个oo相连符合条件，带oooo符合条件；（）要用egrep使用； 
sed -n '5'p test.txt
sed -n '1,5'p test.txt
sed -n  '/root/'p passwd	#匹配root的正则，-n禁止打印无关内容, p把内容打印出来；
sed -n -e '/sh$/'p -e '1,3'p  passwd		#-e指定多个条件,同时生效的行，会打印2次；
sed -n -e '/nfs/'Ip  passwd		#I不区分大小写；
sed '1,3’d passed #去除1-3行，后显示内容；
sed ‘1,2s/ot/to/g’ passwd #1-2行中所有ot改成to显示出来；
sed -r 's/([^:]*):(.*):([^:]*)/\3:\2:\1/' passwd		#第一段与最后一段的替换，\3 \2\1代表前面的小括号内容，-r可以识别扩展符号例如(), +;
sed /sbin/nologin:x:1:1:bin:/bin:bin #上面命令的结果；
sed 's/^.*$/111&/g' -i passwd		#&代表查找出来的内容，这里是全部匹配，在行前面加上111, -i把内容写入文件;
sed 111bin:x:1:1:bin:/bin:/sbin/nologin #上面命令的结果；
sed 's/([0-9]+)(.*)/\2/' -i my_lish.h			#可以把文件所有行码去除，用空格分开的文字；
awk -F ':' '{print $1":"$3,$4}' passwd	#-F指定分隔符:，打印出每行的第一第三第四段，打印格式用双引号添加分隔符，以逗号分隔用空格分隔；$0为所有段；
awk -F ':' '$6 ~ /home/ {print $1,$3,$4} /mysql/ {print $1,$3,$4}' passwd	#同时判断了两个条件，条件1:第六段$6匹配home, 条件2:整句匹配mysql;一个条件满足都会打印；
awk -F ':' '$3>1010 {print $1,$3,$4}' passwd	#可以使用等于==，大于，小于，不等于!=作判断，数字加上双引号判断为字符以ASCII排序;
awk -F ':' '$7!="/sbin/nologin" {print $1,$3,$4}' passwd #用字符判断；
awk -F ':' '$3==$4 && $3>=1000 {print $1,$3,$4} ' passwd	#字段比较，&&同时满足前后两个条件；
awk -F ':' '$3!=$4 || $3==0 {print $1,$3,$4} {OFS=":"}' passwd	#||或者，OFS定义输出格式分格符，不用一个个写出来；
awk -F ':' '{print NR":"NF}' passwd	#打印每一行的行号NR和段数NF；
awk -F ':' 'NR>40 || NR==1' passwd		#NF,NR作为条件使用；
awk -F ":" '{(tot=tot+$3)} END {print tot}' passwd		#循环语句，没有END遍历一行就print一次tot;END类似continue;
awk -F ":" 'NR>7 {print $(NR/7)":"NR":"$NF}' passwd	#$加数字是第几段；
tail -3 passwd |awk -F ":" '$3="root"'					#对第三段赋值；cat file.txt | awk '{ if ($7~/'"$i"'/) {print $0} }'| wc -l ; #用选取一段匹配另外一个变量；
command audit  #https://blog.csdn.net/tanyyinyu/article/details/100945326
sar -n DEV 1 10		#-n显示网络相关信息，DEV按网卡列出，1代表1秒刷一次，10代表显示10个结果；
sar -n DEV -f /var/log/sa/sa16 #-f从文件里读取信息，命令的前半部分跟查看网络实时信息一样；
sar -q 1 10 #查看实时负载情况；
sar -q -f /var/log/sa/sa16 #从文件里查看负载情况；
ar -b 1 10 #查看实时磁盘情况；
sar -b -f /var/log/sa/sa16 #从文件里查看磁盘情况；
cat /var/log/sa/sar16 #sardd文件可以直接用cat查看；
network nload
iostat -dx		#-d不显示cpu相关信息，-x显示详细信息，不带参数显示简单信息；
iostate -dx 1 10 #动态显示10次，不带10一直动态显示；
iotop
ps -elf
ps -eLf #查看线程的命令；
ps -elf #跟 ps aux差不多；
ss -an
ss -an |grep -i listen
tcpdump -nn -i ens33 #-nn以数字形式显示IP和端口，-i指定网卡，侦听网卡的数据；
tcpdump -nn -i ens33 port 80 #指定侦听端口，可以查看指定服务的数据；
tcpdump -i ens33 -nn not port 22 and port 80 and not host 192.168.31.101 #同时增加几个条件；
tcpdump -nn -i ens33 -c 100 -w 1.cap #-c指定抓包的数量；-w将抓包内容写到文件里，文件不能直接cat;
tcpdump -nn -r 1.cap #-nn也起作用，读取抓包文件，也可以让wireshark分析；
tshark -i ens33 -n -t a -R http.request -T fields -e "frame.time" -e "ip.src" -e "http.host" -e "http.request.method" -e "http.request.uri"			 #-t a抓包的时间；-R指定的过滤条件是http请求；-T指定输出格式，内容跟在-e后面，时间，源，域名，请求方法，请求的链接；
network mii-tool ens33
network ethtool ens33
echo -e "\033[30m 黑色字 \033[0m"
echo -e "\033[31m 红色字 \033[0m"
echo -e "\033[32m 绿色字 \033[0m"
echo -e "\033[33m 黄色字 \033[0m"
echo -e "\033[34m 蓝色字 \033[0m"
echo -e "\033[35m 紫色字 \033[0m"
echo -e "\033[36m 天蓝字 \033[0m"
echo -e "\033[37m 白色字 \033[0m"
iptables -F #清空配置，运行后生效，重启恢复默认；
service iptabes save #运行后目前配置保存为默认；
yum install -y iptables-services #安装iptables-services;
iptables -nvL #查看目前iptables设置；
iptables -A INPUT -s 192.168.188.1 -p tcp --sport 1234 -d 192.168.188.128 --dport 80 -j DROP #-A新增规则，-s源IP，-p协议类型, --sport 1234源端口1234, -d接目的IP, --dport 80目的端口80, 符合前面条件的, -j DROP丢弃包；
iptables -I INPUT -p tcp --dport 80 -j DROP #-I添加规则在第一行；指定端口必须要指定-p;
iptables -D INPUT -p tcp --dport 80 -j DROP #-D删除一条规则，具体内容跟你增加时一样；
iptables -nvl --line-number #查看规则编号，可按编号删除；
iptables -D INPUT 7 #删除INPUT中编号7规则；
iptables -I INPUT -s 192.168.1.0/24 -i eth0 -j ACCEPT #-i接收包的网卡；
iptables -P OUTPUT DROP #-P修改链的默认策略，OUTPUT链全盘丢弃，如果ssh连接中，连接会中断；-P设置会变成默认的一部分，除非另外修改，-F不能清除；
iptables -P OUTPUT ACCEPT #OUTPUT改成接受；
iptables -A INPUT -m state --state RELATED,ESTABLISHED -j ACCEPT   #开放的端口连接后，与这些服务相关的，建立连接的其他通信放行，没有这句可能会有问题；
iptables -I INPUT -p icmp --icmp-type 8 -j DROP  #ping出去，不被ping的设置;
route add default gw 192.168.100.1 		#设置网关为机器A的内网网卡IP；
#route - show / manipulate the IP routing table，修改影响力是很大的，设置这个后原来网卡配置文件的网关可能没用了，会导致一些问题，如ping不通外网，要比较注意，查找问题会比较麻烦。
route -n  #查看网关；
echo "1" > /proc/sys/net/ipv4/ip_forward  #开启转发；
iptables -t nat -A POSTROUTING -s 192.168.100.100 -o ens33 -j MASQUERADE  #转发设置 
iptables -t nat -A PREROUTING -d 192.168.133.130 -p tcp --dport 1122 -j DNAT --to 192.168.100.100:22		#设置访问A外网IP1122端口转发到电脑B的22端口；
iptables -t nat -A POSTROUTING -s 192.168.100.100 -j SNAT --to 192.168.133.130		#设置电脑B的IP发出的包，改成为电脑A外网IP，跟A1122端口通信等于跟B通信；
service iptables save	#会把规保存到/etc/sysconfig/iptables;
service iptables restart		#重启后从配置文件里加载配置；
iptables-save > ipt.txt		#把配置文件保存在自定义文件里；
iptables-restore < ipt.txt		#从文件恢复规则；
iptables-save -t nat > ipt2.txt
iptables-restore < ipt2.txt
firewall-cmd --get-default-zone
firewall-cmd --get-zones		#查看所有zones;
firewall-cmd --get-zone-of-interface=ens33
firewall-cmd --get-active-zones  	#查看活动的zone和对应的接口;
firewall-cmd --set-default-zone=block  ##修改default-zone，原来public-zone网卡受影响；
firewall-cmd --zone=public --add-interface=lo		#添加网卡到一个zone;
firewall-cmd --zone=dmz --change-interface=lo #改变网卡的zone;
firewall-cmd --zone=dmz  --remove-interface=lo		#从一个zone中删除网卡；
firewall-cmd --get-services 		#查看所有services;
firewall-cmd --zone=public --add-service=http #临时增加services，重启后需要重新添加;
firewall-cmd --zone=public --remove-service=http	 #删除services;
firewall-cmd --zone=public --add-service=http --permanent  #使用permanent参数后，修改更新在配置文件里，重启后也会加载；
firewall-cmd --zone=block --add-port=80/tcp		#添加端口；
firewall-cmd --zone=block --list-port		#列出zone的端口；
firewall-cmd --zone=block --remove-port=80/tcp
firewall-cmd --zone=public --add-port=8730/udp --permanent  
firewall-cmd --zone=public --add-port=8730/tcp --permanent  
firewall-cmd --reload 
firewall-cmd --zone=public --list-ports 
firewall-cmd --permanent --add-rich-rule='rule family=ipv4 source address="192.168.1.188" port port=20-21 protocol=tcp accept'	#开通某一个IP访问20-21端口；
firewall-cmd --permanent --add-rich-rule='rule protocol value=icmp drop'  #不能被ping的设置；
firewall-cmd --zone=public --add-masquerade --permanent  #外网网卡的zone添加masquerade;#转发；
firewall-cmd --remove-masquerade --permanent   #取消的命令
firewall-cmd  --direct --passthrough ipv4 -t nat -A POSTROUTING -o ens33 -s 172.16.92.0/24 -j MASQUERADE  #转发；
firewall-cmd --reload  #转发；
firewall-cmd --zone=public --add-forward-port=port=1122:proto=tcp:toport=22:toaddr=172.16.92.154 --permanent  #端口映射；
firewall-cmd --reload  #端口映射；
firewall-cmd --zone=public --remove-forward-port=port=1122:proto=tcp:toport=22:toaddr=172.16.92.154 --permanent   #取消的命令；
firewall-cmd --list-all #查看zone的所有规则；
firewall-cmd --list-all-zones	#查看所有zone的所有规则；
crontab -e		#打开一个类似vi的界面，按上面的格式逐行写下计划；
crontab -l		#查看计划；
crontab 1 3 */2 1-6 1,2,3,4,5  /bin/bash ~/123.sh	#1-6月,双数的日子的3时1分，周一到周五实施计划；
systemctl start crond		#启动计划；
systemctl status crond		#查看服务状态；
crontab -u user1 -l	#查看某个user的计划；
crontab /var/spool/cron/user1			#这个路径保存着计划的文件，可用于备份，以每个用户名为名；
crontab 1 3 */2 1-6 1,2,3,4,5  /bin/bash ~/123.sh >> 123.log	2>> 123e.log	#可以保存正确和错误信息；
rsync -avL	#-L把软链接的源文件同步到目的地；
rsync -avP	#-P显示同步过程，增加速率的显示；
rsync -avu	#-u目的地的文件版本比源版本新，则不更新；
rsync -avz 	#-z传输时压缩；
rsync -av --delete /tmp/rsyn1/ 172.16.92.142:/tmp/rsyn2/ #--delete删除目的地 中 源 没有的文件，原来是增量同步；
rsync -av --exclude "*.log" /tmp/rsyn1/ 172.16.92.142:/tmp/rsyn2/ #--exclude排除某些文件不同步；
rsync -av -e "ssh -p 1122" test1/ 192.168.133.132:/tmp/test2/  	#可以结合iptable nat表的应用，外网机器ssh内外网机器:1122 <-> 内网机器:22,可通过一台机器从外部访问只具内网连接的机器；
dmesg  #硬件相关日志，保存在内存
/var/log/dmesg  #系统启动记录的日志
last #登陆系统的记录 日志；
lastb  #登陆系统失败的记录 日志；
/var/log/secure  #登陆系统的相关信息 日志；
